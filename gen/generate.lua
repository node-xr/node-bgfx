local idl = require("./deps/bgfx/scripts/idl")
local util = require("./gen/util")
local napi = require("./gen/napi")
local misc = require("./gen/miscfuncs")
local to_snake_case = util.to_snake_case

-- Load the BGFX interface description file.
do
  local bgfx_idl, err = loadfile("./deps/bgfx/scripts/bgfx.idl", "t", idl)
  print(bgfx_idl, err)
  bgfx_idl()
end

local function format_enum_entry(key, value, needs_comma, comment, indent)
  indent = string.rep(" ", indent or 2)
  return indent .. string.format("%-20s: %2d%s", key, value,
    ((needs_comma and ",") or " ") .. ((comment and " // "..comment) or ""))
end

local function gen_enum(e)
  local frags = {"exports." .. to_snake_case(e.name):upper() .. " = {"}
  for i, v in ipairs(e['enum']) do
    local keyname = to_snake_case(v.name):upper()
    local needs_comma = (i ~= #e['enum'])
    frags[#frags+1] = format_enum_entry(keyname, i-1, needs_comma, v.comment)
  end
  frags[#frags+1] = "}"
  return table.concat(frags, "\n")
end

-- Put enums into the contents of the JS binding.
-- Register other handle types with the native api.
local js_body = {}
for k, v in pairs(idl.types) do
  if v['enum'] then
    js_body[#js_body + 1] = {gen_enum(v), ""}
    napi:add_enum_type(v.name .. "::Enum", v)
  elseif v.handle then
    napi:add_handle_type(v.name, v)
  end
end

-- Iterate through the list of functions and create bindings.
local n_success, n_err  = 0, 0
local export_body, cpp_body, hpp_body = {}, {}, {}
misc.add(idl.funcs)
for k, v in pairs(idl.funcs) do
  if not v.cpponly then
    local name, capi_name, signature, body, had_errors = napi:gen_function(v)

    cpp_body[#cpp_body + 1] = {body, ""}
    hpp_body[#hpp_body + 1] = ((had_errors and "//") or "") .. signature .. ";"

    if had_errors then
      n_err = n_err + 1
    else
      export_body[#export_body + 1] = ('export_function(env, exports, "%s", %s);'):format(capi_name, name)
      n_success = n_success + 1
    end
  end
end

local dest_cpp = util.conflatten{
[[
// Autogenerated -- DO NOT EDIT
#include "bgfx.hpp"
#include <bgfx/c99/bgfx.h>
#include <string.h>

]],
cpp_body,
[[
napi_value create_bgfx(napi_env env)
{
  napi_value exports;
  ASSERT_OK(napi_create_object(env, &exports), "EINVAL", "Failed to create exports.");
]],
util.indent(export_body),
[[
  return exports;
}
]]
}

local dest_hpp = util.conflatten{
[[
// Autogenerated -- DO NOT EDIT
#pragma once
#include "util.hpp"
#include <node_api.h>

napi_value create_bgfx(napi_env env);
]],
hpp_body, 
""
}

local dest_js = util.conflatten{
[[
// Autogenerated -- DO NOT EDIT
]],
js_body
}

print("Converted: ", n_success, " / ", n_success + n_err)
napi:print_missing_types()

return dest_cpp, dest_hpp, dest_js